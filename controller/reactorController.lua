---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Will.
--- DateTime: 12/24/2020 7:37 AM
---

os.loadAPI("json")

local reactor = peripheral.wrap("back")

local SERVER = 575 -- SET THIS VALUE TO THE ID OF THE REACTOR
local CLIENT = 576 -- SET THIS VALUE TO THE ID OF THE DISPLAY MACHINE

local ENERGY_MAX = 10000000
local FUEL_MAX = reactor.getFuelAmountMax()
local THRESHOLD = 60
local MINIMUM = 40

local loopTicks = 10

-- Create websocket connection to the IRL server.
function openWebsocketConnection()
    local ws,err = http.websocket("ws://controller-diamondfire11.ngrok.io")
    if err then
        print(err)
    end

    if ws then
        print(ws.receive())
        return ws
    end
end

-- Configure control client settings
function getConfigFile(ws)
    local cfg = fs.open("cfg.txt", "r")
    if not cfg then
        print("Config file not found creating.")
        cfg = fs.open("cfg.txt", "w")

        -- Get next available ID
        ws.send('{"task":"get-id"}')
        local id = ws.receive()

        -- Get world name (This is to track what reactors belong to what world)
        print("Enter World/Server: ")
        local world = read()

        print("Enter Reactor Name: ")
        local name = read()

        -- Serialize Server Command
        ws.send(textutils.serializeJSON({
            task = "new",
            ID = id,
            WORLD = world,
            NAME = name
        }))

        -- Commit config data
        cfg.write(textutils.serializeJSON({
            ID = id,
            WORLD = world,
            NAME = name
        }))

        cfg.close()
        cfg = getConfigFile(ws)
    end
    return cfg
end

-- Update server with reactor data
function updateReactorStatus(ws, id, data)
   ws.send(textutils.serializeJSON({
        task = "update-status",
        ID = id,
        activity = data[1],
        energy = data[2],
        saturation = data[3],
        fuel = data[4],
        waste = data[5],
        maxFuel = data[6],
        fuelBurnup = data[9],
        energyOut = data[10],
        coreReactivity = data[7],
        coreTemp = data[8]
    }))
end

-- Update the server with new reactor error
function updateError(ws, id)
    ws.send(textutils.serializeJSON({
        task = "update-error",
        ID = id,
        rfUsage = getRFUsage()
    }))
end

-- Query server for pid adjust
function getPIDCommand(ws, id)
    local rodPercentage = reactor.getControlRodLevel(1)
    ws.send(textutils.serializeJSON({
        task = "run-pid",
        ID = id
    }))

    local rodLevel = rodPercentage + ws.receive()

    if rodLevel > 100 then
        rodLevel = 100
    end

    if rodLevel < 0 then
        rodLevel = 0
    end

    return rodLevel
end

-- Calculate reactor error
function getRFUsage()
    local initialBuffer = reactor.getEnergyStored()
    sleep(0.05*loopTicks)
    local finalBuffer = reactor.getEnergyStored()

    return (finalBuffer - initialBuffer)/loopTicks
end

-- Query reactor for basic operational data
function queryReactor()
    local isActive = reactor.getActive()
    local energyStored = reactor.getEnergyStored()
    local energySaturation = energyStored/ENERGY_MAX
    local fuelLevel = reactor.getFuelAmount()
    local wasteLevel = reactor.getWasteAmount()
    local wasteProduced = reactor.getFuelConsumedLastTick()
    local rfProduced = reactor.getEnergyProducedLastTick()
    local reactivity = reactor.getFuelReactivity()
    local temp = reactor.getFuelTemperature()

    return isActive, energyStored, energySaturation, fuelLevel, wasteLevel, FUEL_MAX, reactivity, temp, wasteProduced, rfProduced
end

-- Get reactor ID, used for initial setup
function getID(cfg)
    local line = cfg.readLine()
    local obj = json.decode(line)

    return obj.ID
end

-- Query reactor for the control rods and get levels.
function getControlRods()
    local numberOfRodsInstalled = reactor.getNumberOfControlRods()-1
    local rodLevels = {}
    for i = 0, numberOfRodsInstalled do
        table.insert(rodLevels, reactor.getControlRodLevel(i))
    end

    return rodLevels
end

-- Send the reactor data to the info panel
function sendDataToControlPanel(reactorData)
    rednet.open("bottom")
    rednet.send(CLIENT, reactorData)
    rednet.close("bottom")
end

-- Main control loop
function passiveController(ws, id)
    local reactorData = table.pack(queryReactor())
    local controlRodData = table.pack(getControlRods())
    local rodLevel

    table.insert(reactorData, controlRodData)

    -- Shutoff the reactor if the energy buffer raises above a set threshold
    if reactorData[3]*100 < THRESHOLD then
        if reactorData[3]*100 > MINIMUM then
            print("Buffer power below threshold.")
            reactor.setActive(true)
            if ws then
                updateError(ws, id)
                rodLevel = getPIDCommand(ws, id)
                reactor.setAllControlRodLevels(rodLevel)
            end
            print(rodLevel)
        else
            print("Buffer below minimum threshold")
            reactor.setAllControlRodLevels(0)
            reactor.setActive(true)
            sleep(0.5)
        end
    else
        print("Buffer power above threshold.")
        reactor.setActive(false)
        sleep(0.5)
    end

    print("\n", table.unpack(reactorData))
    print(" ")
    updateReactorStatus(ws, id, reactorData)
    sendDataToControlPanel(reactorData)
end

-- Program insertion point
function main()
    local ws
    while not ws do
        print('Attempting to connect to Node.js server:')
        sleep(0.1)
        ws = openWebsocketConnection() -- Attempt to open websocket connection with controller
    end

    local cfg = getConfigFile(ws)
    local id = getID(cfg)

    local running = true
    while running do
        passiveController(ws, id)
    end
end
main()
